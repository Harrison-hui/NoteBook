## 概念

矩阵(matrix)是数组的分支，二维数组也叫矩阵，两者有时候可通用

```Python
m0 = np.matrix(np.array([[1, 2, 3, 4], [5, 6, 7, 8]]))
print(m0, type(m0))
"""
[[1 2 3 4]
 [5 6 7 8]] <class 'numpy.matrix'>
"""
```


## 矩阵创建

### matrix对象

`matrix(data, dtype=None, copy=True)`

1. **data**: 可以是字符串或类似数组对象。**如果是字符串，该字符串通过","或" "分隔列，通过";"分隔行**

2. dtype: 同数组

3. copy: 同数组。默认为True

```Python
# 基本创建
m0 = np.matrix([1, 2, 3, 4])
print(m0)
"""
[[1 2 3 4]]
"""

m1 = np.matrix([[1, 2, 3, 4], [5, 6, 7, 8]])
print(m1)
"""
[[1 2 3 4]
 [5 6 7 8]]
"""

m2 = np.matrix(np.array([[1, 2, 3, 4], [5, 6, 7, 8]]))
print(m2)
"""
[[1 2 3 4]
 [5 6 7 8]]
"""

m3 = np.matrix("1 2 3 4;5 6 7 8")
print(m3)
"""
[[1 2 3 4]
 [5 6 7 8]]
"""

m4 = np.matrix("1, 2, 3, 4;5, 6, 7, 8")
print(m4)
"""
[[1 2 3 4]
 [5 6 7 8]]
"""


# 设置dtype
m5 = np.matrix("1 2 3 4;5 6 7 8", dtype=np.float64)
print(m5)
"""
[[1. 2. 3. 4.]
 [5. 6. 7. 8.]]
"""



# 设置copy
n0 = np.array([[1, 2, 3, 4], [5, 6, 7, 8]])
m6 = np.matrix(n0, copy=True)
n0[0] = 10
m6[1] = 20
print(n0, m6)
"""
[[10 10 10 10]
 [ 5  6  7  8]] 

[[ 1  2  3  4]
 [20 20 20 20]]
"""

n0 = np.array([[1, 2, 3, 4], [5, 6, 7, 8]])
m7 = np.matrix(n0, copy=False)
n0[0] = 10
m7[1] = 20
print(n0, m7)
"""
[[10 10 10 10]
 [20 20 20 20]] 

[[10 10 10 10]
 [20 20 20 20]]
"""

```


### asmatrix函数（mat函数）

`asmatrix(data, dtype=None)`

`mat(data, dtype=None)`

<=>`matrix(data, dtype=None, copy=False)`

```Python
n0 = np.array([[1, 2, 3, 4], [5, 6, 7, 8]])
m8 = np.asmatrix(n0)
n0[0] = 10
m8[1] = 20
print(n0, m8)
"""
[[10 10 10 10]
 [20 20 20 20]] 

[[10 10 10 10]
 [20 20 20 20]]
"""



n0 = np.array([[1, 2, 3, 4], [5, 6, 7, 8]])
m9 = np.mat(n0)
n0[0] = 10
m9[1] = 20
print(n0, m9)
"""
[[10 10 10 10]
 [20 20 20 20]] 

[[10 10 10 10]
 [20 20 20 20]]
"""
```


## 矩阵属性

与数组对象共有相同的属性，同时尤其独特的属性

4. **A**: 转换为数组

5. **A1**: 转换为一维数组

6. **H**: 转置后求复数的共轭复数，若只有实部则相当于转置

7. **I**: 逆矩阵。矩阵与其逆矩阵相乘的结果是np.matrix(np.eye(self[0,:].size))，只是浮点数计算存在精度问题

```Python
m0 = np.matrix(np.array([[1, 2], [3, 4]]))
print(m0, type(m0))
"""
[[1 2 3 4]
 [5 6 7 8]] <class 'numpy.matrix'>
"""

# A: 转换为数组
m1 = m0.A
print(m1, type(m1))
"""
[[1 2 3 4]
 [5 6 7 8]] <class 'numpy.ndarray'>
"""



# A1: 转换为一维数组
m2 = m0.A1
print(m2, type(m2))
"""
[1 2 3 4 5 6 7 8] <class 'numpy.ndarray'>
"""



# I: 求逆
m3 = m0.I
print(m3)
"""
[[-5.50000000e-01  2.50000000e-01]
 [-2.25000000e-01  1.25000000e-01]
 [ 1.00000000e-01 -2.10437669e-17]
 [ 4.25000000e-01 -1.25000000e-01]]
"""

m4 = m0 * m3
print(m4)
"""
[[ 1.00000000e+00 -2.77555756e-16]
 [ 1.33226763e-15  1.00000000e+00]]
"""



# H: 转置后求复数的共轭复数，若只有实部则相当于转置
m4 = m0.H
print(m4)
"""
[[1 5]
 [2 6]
 [3 7]
 [4 8]]
"""

m5 = m0 + m0 * 1j
print(m5)
"""
[[1.+1.j 2.+2.j 3.+3.j 4.+4.j]
 [5.+5.j 6.+6.j 7.+7.j 8.+8.j]]
"""

m6 = m5.H
print(m6)
"""
[[1.-1.j 5.-5.j]
 [2.-2.j 6.-6.j]
 [3.-3.j 7.-7.j]
 [4.-4.j 8.-8.j]]
"""
```


## 矩阵运算

与数组运算基本相同，但对于矩阵的乘法运算中，* 也是执行点积运算，原理是将两个数组或矩阵（至少有一个是矩阵）均执行asmatrix函数后再执行dot函数。（注意：multiply函数不发生变化）

```Python
n0 = np.arange(1, 17).reshape(4, 4)
print(n0)
"""
[[ 1  2  3  4]
 [ 5  6  7  8]
 [ 9 10 11 12]
 [13 14 15 16]]
"""

n1 = np.array([1, 2, 3, 4])
print(n1)
"""
[1 2 3 4]
"""

print(n0 * n1)
"""
[[ 1  4  9 16]
 [ 5 12 21 32]
 [ 9 20 33 48]
 [13 28 45 64]]
"""

print(n1 * np.asmatrix(n0))
"""
[[ 90 100 110 120]]
"""
```






